---
title: 'Chisel学习'
description: 'Chisel学习'
publishDate: '2025-09-27'
tags: ['Chisel', 'Scala']
heroImage: { src: './a.jpg' }
language: 'Chinese'
---
使用了比较长时间的 Chisel，但是一直没有系统的学习过 Chisel，所以依照[Chisel Bootcamp](https://hub.gesis.mybinder.org/user/freechipsproject-chisel-bootcamp-knb6vajo/lab/workspaces/auto-Q)学习了一遍，记录一些学习笔记。

## Scala 语法

[Scala 文档](https://www.scala-lang.org/api/current/docs/index.html)

`.permutations` 函数可以生成所有可能的排列组合,示例：

```scala
val list = List(1, 2, 3)
val permutations = list.permutations
// 输出: List(List(1, 2, 3), List(1, 3, 2), List(2, 1, 3), List(2, 3, 1), List(3, 1, 2), List(3, 2, 1))
```
`.reduce` 函数可以用来将列表中的元素进行聚合，示例：
```scala
val list = List(1, 2, 3)
val sum = list.reduce(_ + _)
// 输出: 6
```

`.fold` 函数可以用来将列表中的元素进行聚合,同时可以指定初始值，示例：
```scala
val list = List(1, 2, 3)
val sum = list.fold(2)(_ + _)
// 输出: 8
```





`.foreach` 函数可以遍历列表中的每个元素，示例：

```scala
val list = List(1, 2, 3)
list.foreach(println)
// 输出: 1 2 3
```

`.zip` 函数可以将两个列表合并成一个列表，示例：

```scala
val list1 = List(1, 2, 3)
val list2 = List(4, 5, 6)
val zipList = list1.zip(list2)
// 输出: List((1,4), (2,5), (3,6))
```

`.zipWithIndex` 函数可以将两个列表合并成一个列表，并添加索引，示例：
```scala
val list1 = List(1, 2, 3)
val zipList = list1.zipWithIndex
// 输出: List((1,0), (2,1), (3,2))
```


`Seq.tabulate`函数可以生成一个列表，示例：
```scala
val list = Seq.tabulate(10)(_ * 2)
// 输出: List(0, 2, 4, 6, 8, 10, 12, 14, 16, 18)
```

`require`语句可以用来检查条件是否满足，示例：
```scala
require(x > 0, "x must be greater than 0")
```

`match`语句可以用来匹配模式，示例：
```scala
val x = 1
val result = x match {
  case 1 => "one"
  case 2 => "two"
  case _ => "other"
}
// 输出: "one"

//类型匹配
val x: Any = 1
val result = x match {
  case i: Int => "int"
  case s: String => "string"
  case _ => "other"
}
// 输出: "int"
val numbers = List(1, 2, -3, 4)

val converted = numbers.map(x => x match {
  case n if n >= 0 => s"Number: $n"
  case _           => "Error: Negative number"
})
// 输出: List("Number: 1", "Number: 2", "Error: Negative number", "Number: 4")
```

`.getOrElse`函数可以用来获取列表中的元素，示例：
```scala
val list = List(1, 2, 3)
val element = list.getOrElse(1, 0)
// 输出: 2

val some = Some(1)
val element = some.getOrElse(0)
// 输出: 1

val none = None
val element = none.getOrElse(0)
// 输出: 0
```
### implicits语法
implicit function 可以用来实现一些隐式转换，示例：
```scala
class Animal(val name: String, val species: String)
class Human(val name: String)
implicit def human2animal(h: Human): Animal = new Animal(h.name, "Homo sapiens")
val me = new Human("Adam")
println(me.species)
// 输出: Homo sapiens
```
上面的例子中，`me` 是 `Human` 类型，但是可以调用 `Animal` 的 `species` 方法，因为 implicit function 实现了隐式转换。

### Seq
Seq 是 Scala 中的一个抽象类，它又一些具体的实现类，比如 `List`、`Vector`、`Array` 等。一个函数的参数使用 `Seq[]` 可以接受这些具体的实现类，示例：
```scala
def printSeq(seq: Seq[Int]): Unit = {
  seq.foreach(println)
}
printSeq(List(1, 2, 3))
```

### ArrayBuffer
ArrayBuffer 是 Scala 中的一个可变数组，可以用来实现元素的动态添加和删除，示例：
```scala
val buffer = ArrayBuffer[Int]()
buffer.append(1)
buffer.append(2)
buffer.append(3)
buffer += 4
println(buffer)
// 输出: ArrayBuffer(1, 2, 3, 4)
```

### 函数式编程
Scala 中的函数是第一类公民，可以像变量一样被赋值、作为参数传递和作为返回值返回。
```scala
val add = (x: Int, y: Int) => x + y
println(add(1, 2))
// 输出: 3
def add(x: Int, y: Int): Int = x + y
println(add(1, 2))
// 输出: 3
```

匿名函数只可以调用一次，一次不需要 val 定义。
```scala
val myList = List(5, 6, 7, 8)
myList.map( (x:Int) => x + 1 )
myList.map(_ + 1)
```




## Chisel test
Chisel 内置了一些简单的测试函数，要设置输入，调用 `poke` 函数，然后调用 `expect` 函数来验证输出；如果没有要检查的输出，可以调用 `peek`。

## Verilog and FIRRTL generation
Chisel 可以生成 Verilog 和 FIRRTL 代码。

可以使用 `getVerilog` 和 `getFirrtl` 函数来生成 Verilog 和 FIRRTL 代码。

## Combination and sequential circuits
Chisel 可以很方便的实现组合逻辑和时序逻辑,具体细节可参考[Chisel cheatsheet](https://github.com/freechipsproject/chisel-cheatsheet/releases/latest/download/chisel_cheatsheet.pdf)

### 优先仲裁实现示例
下面是一个优先仲裁的实现示例，使用 Chisel 实现。
```scala
class Arbiter extends Module {
  val io = IO(new Bundle {
    // FIFO
    val fifo_valid = Input(Bool())
    val fifo_ready = Output(Bool())
    val fifo_data  = Input(UInt(16.W))
    
    // PE0
    val pe0_valid  = Output(Bool())
    val pe0_ready  = Input(Bool())
    val pe0_data   = Output(UInt(16.W))
    
    // PE1
    val pe1_valid  = Output(Bool())
    val pe1_ready  = Input(Bool())
    val pe1_data   = Output(UInt(16.W))
  })

  io.fifo_ready := io.pe0_ready || io.pe1_ready
  io.pe0_valid := io.fifo_valid && io.pe0_ready
  io.pe1_valid := io.fifo_valid && io.pe1_ready && !io.pe0_ready
  io.pe0_data := io.fifo_data
  io.pe1_data := io.fifo_data
}

test(new Arbiter) { c =>
  import scala.util.Random
  val data = Random.nextInt(65536)
  c.io.fifo_data.poke(data.U)
  
  for (i <- 0 until 8) {
    c.io.fifo_valid.poke((((i >> 0) % 2) != 0).B)
    c.io.pe0_ready.poke((((i >> 1) % 2) != 0).B)
    c.io.pe1_ready.poke((((i >> 2) % 2) != 0).B)

    c.io.fifo_ready.expect((i > 1).B)
    c.io.pe0_valid.expect((i == 3 || i == 7).B)
    c.io.pe1_valid.expect((i == 5).B)
    
    if (i == 3 || i ==7) {
      c.io.pe0_data.expect((data).U)
    } else if (i == 5) {
      c.io.pe1_data.expect((data).U)
    }
  }
}
println("SUCCESS!!")
```
### queue实现示例
使用 `Queue` 函数可以很方便的实现队列
```scala
class QueueModule[T <: Data](ioType: T, entries: Int) extends MultiIOModule {
  val in = IO(Flipped(Decoupled(ioType)))
  val out = IO(Decoupled(ioType))
  out <> Queue(in, entries)
}
```

## 时钟与复位
Chisel 模块具有默认的时钟和复位，同时也可以自定义时钟和复位。可以使`withClock() {}` 、 `withReset() {}` 和 `withClockAndReset() {}` 来覆盖默认的时钟和复位。
```scala
import chisel3.experimental.{withClock, withReset, withClockAndReset}

class ClockExamples extends Module {
  val io = IO(new Bundle {
    val in = Input(UInt(10.W))
    val alternateReset    = Input(Bool())
    val alternateClock    = Input(Clock())
    val outImplicit       = Output(UInt())
    val outAlternateReset = Output(UInt())
    val outAlternateClock = Output(UInt())
    val outAlternateBoth  = Output(UInt())
  })

  val imp = RegInit(0.U(10.W))
  imp := io.in
  io.outImplicit := imp

  withReset(io.alternateReset) {
    // everything in this scope with have alternateReset as the reset
    val altRst = RegInit(0.U(10.W))
    altRst := io.in
    io.outAlternateReset := altRst
  }

  withClock(io.alternateClock) {
    val altClk = RegInit(0.U(10.W))
    altClk := io.in
    io.outAlternateClock := altClk
  }

  withClockAndReset(io.alternateClock, io.alternateReset) {
    val alt = RegInit(0.U(10.W))
    alt := io.in
    io.outAlternateBoth := alt
  }
}
```


## 参数化模块
当参数没有合适的默认值时，可以使用 Option 的 None 来表示没有默认值。
```scala
class DelayBy1(resetValue: Option[UInt] = None) extends Module {
    val io = IO(new Bundle {
        val in  = Input( UInt(16.W))
        val out = Output(UInt(16.W))
    })
    val reg = if (resetValue.isDefined) { // resetValue = Some(number)
        RegInit(resetValue.get)
    } else { //resetValue = None
        Reg(UInt())
    }
    reg := io.in
    io.out := reg
}
```

可以使用 None 来可选的设置参数。
```scala
class HalfFullAdder(val hasCarry: Boolean) extends Module {
  val io = IO(new Bundle {
    val a = Input(UInt(1.W))
    val b = Input(UInt(1.W))
    val carryIn = if (hasCarry) Some(Input(UInt(1.W))) else None
    val s = Output(UInt(1.W))
    val carryOut = Output(UInt(1.W))
  })
  val sum = io.a +& io.b +& io.carryIn.getOrElse(0.U)
  io.s := sum(0)
  io.carryOut := sum(1)
}
```

## 硬件集合
Chisel 集合类型 Vec 可以用来实现硬件集合，比如一个 Bundle 类型的集合或者寄存器文件的组合。
```scala
val consts = Input(Vec(length, UInt(8.W))) // 一个长度为 length 的 UInt(8.W) 类型的集合
val regs = RegInit(VecInit(Seq.fill(length - 1)(0.U(8.W)))) // 一个长度为 length - 1 的 UInt(8.W) 类型的集合
```

## Chisel 标准单元
### Decoupled
Decoupled 是 Chisel 中的一个抽象类，它有一些具体的实现类，比如 `DecoupledIO`、`DecoupledIOBundle` 等。一个函数的参数使用 `Decoupled[]` 可以接受这些具体的实现类，示例：
主要使用在声明接口时，将数据放入 `bits` 当中，并声明 `valid` 和 `ready` 信号。
```Scala
class DecoupledModule[T <: Data](ioType: T) extends Module {
    val io = IO(new Bundle {
        val in = Flipped(Decoupled(ioType))
        val out = Decoupled(ioType)
    })
    io.out.bits := io.in.bits
}
```

### Queues
Queue 是一个先进先出的 FIFO ， 端口均采用 Decoupled 接口。简单示例：
```Scala
class QueueModule[T <: Data](ioType: T, entries: Int) extends MultiIOModule {
  val in = IO(Flipped(Decoupled(ioType)))
  val out = IO(Decoupled(ioType))
  out <> Queue(in, entries)
}
```

### Arbiters
Arbiters 是由组合逻辑实现的，将n个 `DecoupledIO` 路由到唯一的 `DecoupledIO` 。
- `Arbiter` ：优先考虑指数较低的生产者
- `RRArbiter` ：循环仲裁
简单示例：
```Scala
class ArbiterModule[T <: Data](ioType: T, n: Int) extends MultiIOModule {
  val in = IO(Vec(n, Flipped(Decoupled(ioType))))
  val out = IO(Decoupled(ioType))
  val arbiter = Module(new Arbiter(ioType, n))
  arbiter.io.in <> in
  out <> arbiter.io.out
}
```

### 更多标准单元查阅 Cheatsheet

## Scala 高阶函数的应用
```Scala
io.out := (taps zip io.consts).map { case (a, b) => a * b }.reduce(_ + _)
```
上面这个语句可以实现将 `taps` 和 `io.consts` 的每个元素相乘，然后求和。也可使用匿名函数 `(a, b) => a + b` 来实现。

## Chisel 和 Scala 的面向对象编程

### 抽象类
抽象类是一种不能被实例化的类，只能被继承。其中有一些抽象方法，需要子类实现。
```Scala
abstract class MyAbstractClass {
  def myFunction(i: Int): Int
  val myValue: String
}
class ConcreteClass extends MyAbstractClass {
  def myFunction(i: Int): Int = i + 1
  val myValue = "Hello World!"
}
// Uncomment below to test!
// val abstractClass = new MyAbstractClass() // Illegal! Cannot instantiate an abstract class
val concreteClass = new ConcreteClass()      // Legal!
```

### Traits
一个class 可以继承多个Traits，示例：
```Scala
trait HasFunction {
  def myFunction(i: Int): Int
}
trait HasValue {
  val myValue: String
  val myOtherValue = 100
}
class MyClass extends HasFunction with HasValue {
  override def myFunction(i: Int): Int = i + 1
  val myValue = "Hello World!"
}
```
 ### Objects
 单例对象类似于 Java 中的静态类，可以直接引用它
```Scala
object MyObject {
  def hi: String = "Hello World!"
  def apply(msg: String) = msg
}
println(MyObject.hi)
println(MyObject("This message is important!")) // equivalent to MyObject.apply(msg)
```

### 伴生对象
当一个类与一个对象具有相同的名称时，这个类和对象称为伴生类和伴生对象。 使用 `new` 示例化类，直接调用则引用对象。
可以实现一个伴生对象的apply方法，以简化实例化。
```Scala
class MyClass(val name: String)
object MyClass {
  val defaultName = "John"
  def apply(name: String): MyClass = new MyClass(name)
  def apply(): MyClass = apply(defaultName)
}
val myClass = MyClass("John")
```

### Case Classes
Case Classes 是一种特殊的类，通常用于大量参数的配置，其构造函数还能用来检验参数的合法性。
```Scala
case class SomeGeneratorParameters(
    someWidth: Int,
    someOtherWidth: Int = 10,
    pipelineMe: Boolean = false
) {
    require(someWidth >= 0)
    require(someOtherWidth >= 0)
    val totalWidth = someWidth + someOtherWidth
}
```